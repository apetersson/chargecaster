first, read the files from scripts/qnd/batteryctl/backend and compare them logically with the py files from scripts/qnd/batteryctl
your (partially completed) task is to

create an alternative backend in fastify with nest js modules and trpc in scripts/qnd/batteryctl/backend - connect the frontend to the historical and forward data and the current state through trcp. create a simple e2e test with mock data, TDD style. the backend should only use sqlite for now as an embedded data source writing to the data/db folder. in your work loop make sure to lint/typecheck/e2e test after significent changes. try to reach feature-parity with the existing python code - ideally we also have a matching test case in ts to test_simulation.py

the probloem right now.

  - Backend e2e test dashboard tRPC > runs simulation and stores snapshot still fails (Storage service not initialised). When SimulationService.runSimulation()
  executes inside the test harness, the injected StorageService reference is undefined, so persistence calls blow up. We need to make sure the Nest-resolved instance
  survives the tRPC invocation in tests.


Ensure the Nest e2e test for dashboard.runSimulation uses the same SimulationService instance as the tRPC router; adjust the test bootstrap (or service wiring) so
  storageRef isn’t undefined, then rerun yarn lint, yarn typecheck, and yarn test:e2e.


some code quality criteria:

Start with two principles: run TypeScript directly in dev, and keep one typed contract shared across all runtimes so you never handwrite JS or codegen. You will still deploy JS at runtime because Node executes JS, but you never touch JS files during development and you don’t check in generated JS.

Non-negotiables for “pure TS”

One contract source of truth: export router types and shared types from TS only. Avoid OpenAPI, GraphQL codegen, or duplicate DTOs.

Dev runs TS directly with a fast loader (tsx or vite-node). No tsc --watch emitting JS.

Strictest TS: turn on the correctness flags that catch drift early.

ESM consistently, or consistently CJS. Do not mix.

Type-only boundaries: use import type and export type so types vanish at runtime.

Runtime validation at edges with Zod and z.infer for derived types.

Monorepo or project references so server, worker, and client import the same TS types without intermediate JS.

suggested eslint:
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "useUnknownInCatchVariables": true,
    "noImplicitOverride": true,
    "skipLibCheck": false,
    "resolveJsonModule": true,
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "allowJs": false,
    "checkJs": false,
    "declaration": true,
    "emitDeclarationOnly": true,
    "types": []
  },
  "exclude": ["node_modules", "dist"]
}

{
  "name": "batteryctl-backend",
  "private": true,
  "type": "module",
  "packageManager": "pnpm@9.0.0",
  "scripts": {
    "dev:api": "tsx watch apps/api/src/server.ts",
    "dev:worker": "tsx watch apps/worker/src/job.ts",
    "typecheck": "tsc -b --pretty",
    "build": "pnpm -r build",
    "build:trpc": "tsup packages/trpc/src/index.ts --dts --format esm --clean",
    "lint": "eslint ."
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "eslint": "^9.0.0",
    "tsx": "^4.16.0",
    "tsup": "^8.0.0",
    "typescript": "^5.6.0",
    "zod": "^3.23.0",
    "@trpc/server": "^11.0.0",
    "@trpc/client": "^11.0.0",
    "@trpc/server/adapters/fastify": "^11.0.0",
    "superjson": "^2.2.0",
    "fastify": "^5.0.0"
  },
  "pnpm": {
    "packages": {
      "apps/*": {},
      "packages/*": {}
    }
  }
}
